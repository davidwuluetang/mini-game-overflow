# Author: David Tang
# Version 1.1

from overflow import overflow
from overflow import all_cell_same_sign
from data_structures import Queue

MAX_SCORE, MIN_SCORE = 999, -999 # Representing won and lost board

# this function perform deep copy of the board
def copy_board(board):
        current_board = []
        height = len(board)
        for i in range(height):
            current_board.append(board[i].copy())
        return current_board


# this function is your evaluation function for the board
def evaluate_board (board, player):
    player1_score, player2_score = 0, 0 # A total score for both player
    max_row, max_col = len(board), len(board[1])
    
    possible_overflow_cells = [] # A possible overflow cell list for current player

    # A loop to add all the they have in current board as a base score for each player
    for row in range(max_row):
        for col in range(max_col):
            numOfNeighbors = 4
            # Get number of neighbors at current cell
            if row == 0 or row == max_row - 1:
                numOfNeighbors -= 1
            if col == 0 or col == max_col - 1:
                numOfNeighbors -= 1

            if board[row][col] > 0: # Player 1
                player1_score += board[row][col]
                # Base on number of item in cell and number of neighbors it has
                # we can determine wether this cell is one step away from overflow.
                # If yes, then we add it to the possible overflow cell list.
                if numOfNeighbors - 1 == board[row][col] and player == 1:
                    possible_overflow_cells.append((row, col))

            elif board[row][col] < 0: # Same operations but for player 2
                player2_score += abs(board[row][col])
                if numOfNeighbors - 1 == abs(board[row][col]) and player == -1:
                    possible_overflow_cells.append((row, col))

    # A loop of possible overflow cells for current player and add bonus score
    for cell in possible_overflow_cells:
        row, col = cell
        new_board = copy_board(board) # Make a copy of current board
        new_board[row][col] += player # Add one item to make it in overflow state

        queue = Queue()
        # Send the copy board to function overflow()
        numOfRecurs = overflow(new_board, queue)
        if player == 1:
            # Add bonus score base on number of overflow it occur
            player1_score += numOfRecurs
            # If the copy board is in won state, add extra 20 score
            if all_cell_same_sign(new_board) is True:
                player1_score += 20
        else: # Same operations, but for player 2
            player2_score += numOfRecurs
            if all_cell_same_sign(new_board) is True:
                player2_score += 20

    # If either one player have 0 score, some had won or lost the game.
    # Then return their a score that represent won or lost state base on
    # which player is evaluating. Otherwise it return the difference
    # two player's score.
    if (player == 1 and player2_score == 0) or (player == -1 and player1_score == 0):
        return MAX_SCORE
    elif (player == 1 and player1_score == 0) or (player == -1 and player2_score == 0):
        return MIN_SCORE
    elif player == 1:
        return player1_score - player2_score
    else:
        return player2_score - player1_score


# A game tree represent the prediction of result state given by the current state
# and player. Each node (Except the root) represent future state of the game, and
# each branch from the node represent best possible that generate by that state.
class GameTree:
    # Constructor for node
    # board - the board of the game in current state
    # depth - current depth in the tree
    # player - current turn to move of player
    # alpha - a best value the maxPlayer can get at current depth
    # beta - a best value the minPlayer can get at current depth

    # maxPlayer - at even number of depth is maxPlayer, odd depth is minPlayer.
    # The maxPlayer will select maximum score from it children node and minPlayer
    # will select minimum score from it children node.

    # branch_factor - number of branches to create in each node, represent the possible
    # moves generated by generate_moves()

    #tree_height - the upper limit of the tree
    #debug - print debug info if set it to True

    class Node:
        def __init__(self, board, depth, player, alpha=-999, beta=999, maxPlayer=True, branch_factor=2, tree_height=4, debug=False):
            self.score = None # The score current node select from it children
            self.branches = [] # Pointers to it children nodes

            someoneHasWon = False
            # For each child node, first check if someone already won the game
            if depth != 0:
                someoneHasWon = all_cell_same_sign(board)
                # If someone won or current node is a leaf, then evaluate the board
                # and assign it to the score.
            if someoneHasWon or depth == tree_height - 1:
                # Because the board was generate by its parent node, therefore
                # it evaluate the board with parent player, which why "-player"
                # was placed into argument.
                self.score = evaluate_board(board, -player)
                if debug:
                    print("Depth:", depth, "Score:", self.score)
            else:
                # Before it reach the leaf or a end game state continues
                # create child nodes recursively.
                child_score = [] # A list to track all the branch score for current node
                moves = generate_moves(board, player, branch_factor)
                # For each move, it create a child node and append it to self.branches
                for i in range(len(moves)):
                    queue = Queue()
                    row, col = moves[i]
                    # Create a copy of current board and apply the move.
                    new_board = copy_board(board)
                    new_board[row][col] += player
                    overflow(new_board, queue)

                    # After overflow, create child node with the copy board.
                    self.branches.append(GameTree.Node(new_board, depth+1, -player, alpha, beta, not maxPlayer, branch_factor, tree_height, debug))
                    child_score.append(self.branches[i].score)
                    # Append child score that just created

                    # If current player is maxPlayer, then select the maximum score
                    # from its children. Else, select minimum. Also update the best
                    # value accordingly.
                    if maxPlayer:
                        self.score = max(child_score)
                        alpha = max(alpha, self.score)
                    else:
                        self.score = min(child_score)
                        beta = min(beta, self.score)
                    # When alpha and beta intersect, pruning happen. Trimmed part
                    # of would not be create nor evaluate in the game tree.
                    if beta <= alpha:
                        break
                if debug:
                    print("Depth:", depth, "Score:", self.score, "Number of branches:", len(self.branches))


# Constructor for gameTree
    def __init__(self, board, player, branch_factor=2, tree_height=4, debug=False):
        self.player = player
        self.board = copy_board(board)
        self.root = self.Node(board, 0, player, MIN_SCORE, MAX_SCORE, True, branch_factor, tree_height, debug)


# Function to get next move base on current game tree.
    def get_move(self, branch_factor=2):
        possible_moves = generate_moves(self.board, self.player, branch_factor)
        index = 0
        # After game tree created, the root node score is equal to
        # child node's score that it selected to move. The number of
        # possible move is equal to number branches it have. So, return
        # the index of possible_move if they had same score.
        for branch in self.root.branches:
            if self.root.score == branch.score:
                return possible_moves[index]
            index += 1

    def clear_tree(self):
        self.destroy(self.root)
        self.root = None

    def destroy(self, node):
        if node is not None:
            # Destroy game tree bottom-up, and right to left.
            for branch in reversed(node.branches):
                self.destroy(branch)
                node.branches.pop()


# This function select best 2 move from all possible moves.
def generate_moves(board, player, numOfMoves=2):
    max_row, max_col = len(board), len(board[1])
    corners = [(0, 0),
            (0, max_col-1),
            (max_row-1, 0),
            (max_row-1, max_col-1)
            ]

    # A dictionary that hold the move coordinate as key, priority as value.
    possible_moves = dict()
    # A loop that add all possible moves to dictionary and use the cell item as base priority
    if player == 1:
        for row in range(max_row):
            for col in range(max_col):
                if board[row][col] >= 0:
                    possible_moves[(row, col)] = board[row][col]
    else:
        for row in range(max_row):
            for col in range(max_col):
                if board[row][col] <= 0:
                    possible_moves[(row, col)] = abs(board[row][col])

    # A loop that add extra priority to the move
    for move, value in possible_moves.items():
        row, col = move
        neighbor_cells = []
        add_score = 0

        if row - 1 >= 0:
            neighbor_cells.append([row-1, col]) # Top
        if row + 1 < max_row:
            neighbor_cells.append([row+1, col]) # Bottom
        if col - 1 >= 0:
            neighbor_cells.append([row, col-1]) # Left
        if col + 1 < max_col:
            neighbor_cells.append([row, col+1]) # Right

        # Each corner get 2 extra priority, and for player 1 top-left corner
        # get another 1 point; for player 2 bottom-right corner get another point.
        if move in corners:
            add_score += 2
            if player == 1 and move == corners[0]:
                add_score += 1
            if player == -1 and move == corners[3]:
                add_score += 1
        # For each move that potentially overflow get extra 4 points
        if len(neighbor_cells) - 1 == value:
            add_score += 4
        # If that cell have nearby opponent cell that can take over, add another 4 points
            for neighbor_cell in neighbor_cells:
                row, col = neighbor_cell
                if player == 1 and board[row][col] < 0:
                    add_score += 4
                elif player == -1 and board[row][col] > 0:
                    add_score += 4

        possible_moves[move] += add_score

    # Select highest priority moves from dictionary
    two_best_moves = []
    for i in range(numOfMoves):
        if len(possible_moves) != 0:
            best_move = max(possible_moves, key=possible_moves.get)
            two_best_moves.append(best_move)
            possible_moves.pop(best_move)

    return two_best_moves